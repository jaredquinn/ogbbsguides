#!/bin/bash
#
# nl2binkd v1.01
# (c) 2012 by Markus Reschke
# 1.01 changes by Jared Quinn
#
# 1.01 changes may break standards compliance however it creates a binkd
# nodelist from the FTSC fidonet list that is closer to the version
# distributed in the fidonet I-BINKD file echo.
#
# This script extracts nodes with binkd services from the standard Fidonet
# nodelist and creates a special nodelist for binkd.
#


# prepare variables
FLAG=false
STAT=1                                  # exit status


# exit hook for cleaning up
trap 'exit $STAT' 0 1 2 15


# print usage if no arguments provided
case "$*" in
"") echo "Usage:   `basename $0` <nodelist> <binkd nodelist> [domain]";
    echo "Example: `basename $0` NODELIST.006 binkp.nl fidonet";
    echo "Purpose: extract binkp nodes from nodelist";
    exit;;
esac


# check arguments
if [ ! "$2" ]; then
  echo "argument error: please run `basename $0` for usage." 
  exit
fi


# save arguments
NODELIST="$1"
BINKP_NL="$2"
DOMAIN="$3"

# check nodelist
if [ -r "$NODELIST" ]; then
  TEST=`head -1 "$NODELIST" | awk '/Day/ {print $1}'`
  if [ "$TEST" != ";A" ]; then
    echo "File doesn't seem to be a nodelist!"
    exit
  fi
else
  echo "Can't read nodelist!"
  exit
fi


# move binkd nodelist
if [ -w "$BINKP_NL" ]; then
  mv "$BINKP_NL" "$BINKP_NL-old"
fi


# write header for new binkd nodelist
TEST=`head -1 "$NODELIST" | sed 's/;A //' | tr -d '\r'`
echo -e "#\n# binkd nodelist generated by nl2binkd\n# $TEST\n#" > "$BINKP_NL"

# a monster awk script :-)
awk -v binkd_nl="$BINKP_NL" -v domain="$DOMAIN" '
  #
  # functions
  #

  # return IP address/DNS name or port number
  function get_value(conn, type) {
    value = ""

    x = split(conn, token, ":")

    if (x == 1)
    {
      # might be addr or port
      if (type == "addr")
      {
        if (token[1] ~ /^[0-9a-zA-Z.-]+\.[a-zA-Z]+$/) value = token[1]
        else if (token[1] ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) value = token[1]
      }
      else if (type == "port")
      {
        if (token[1] ~ /^[1-9][0-9]*$/) value = token[1]
      }
    }
    else if (x == 2)
    {
      # should be addr:port
      if (type == "addr")
      {
        if (token[1] ~ /^[0-9a-zA-Z.-]+\.[a-zA-Z]+$/) value = token[1]
        else if (token[1] ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) value = token[1]
      }
      else if (type == "port")
      {
        if (token[2] ~ /^[1-9][0-9]*$/) value = token[2]
      }

    }
    else if (x > 2)
    {
      # to many parts
      return value
    }

    # cleanup
    for (y in token)
      delete token[y]

    return value
  }

  #
  # begin
  #

  begin {
    # global variables
    zone = ""
    net = ""
    node = ""
    address = ""
  }

  #
  # main
  #

  {
    # reset variables
    node = ""
    address = ""
    run_flag = "FALSE"
    addr_flag = "FALSE"

    # remove CR
    sub("\\r", "")

    # check for non-comments
    if ($1 !~ /^;[AS]$/)
    {
      # prepare data parsing

      # split line into array (data separated by ",")
      n = split($0, data, ",")
      if (n > 1) run_flag = "TRUE"
    }

    # extract FTS address
    if (run_flag == "TRUE")
    {
      run_flag = "FALSE"

      # get/update all parts of the FTS address
      if (data[1] ~ /^Zone$/)
      {
        # ZC entry
        zone = data[2]
        net = zone
        node = "0"
      }
      else if (data[1] ~ /^Region$/)
      {
        # RC entry
        net = data[2]
        node = "0"
      }
      else if (data[1] ~ /^Host$/)
      {
        # NC entry
        net = data[2]
        node = "0"
      }
      else
      {
        # node entry
        node = data[2]
      }

      # build FTS address
      if (zone != "" && net != "" && node != "")
      {
        address = zone ":" net "/" node
        if (domain != "") address = address "@" domain
        run_flag = "TRUE"
      }      
    }

    # search for IBN flags (=binkd)
    if (run_flag == "TRUE")
    {
      run_flag = "FALSE"
      count = 0

      for (i in data)
      {
        if (data[i] ~ /^IBN/ || data[i] ~ /^BND/)
        {
          run_flag = "TRUE"

          # save IP details if available
          n = length(data[i]);
          if (n > 4)
          {
            count++;
            ip_conn[count] = substr(data[i], 5)
            test = get_value(ip_conn[count], "addr")
            if (test != "")
            {
              addr_flag = "TRUE"
            }
          }
        }
      }
    }

    # search for hidden address in system name
    if (run_flag == "TRUE" && addr_flag == "FALSE")
    {
      count = 0

      # third field is system name
      test = get_value(data[3], "addr")
      if (test != "")
      {
        count++
        ip_addr[count] = test
      }
    }

    # search for hidden address in phone number
    if (run_flag == "TRUE" && addr_flag == "FALSE")
    {
      # sixth field is phone number
      if (data[6] ~ /^000-[0-9]+-[0-9]+-[0-9]+-[0-9]+$/)
      {
        if (data[6] !~ /^000-0+-0+-0+-0+$/)
        {
          count++
          ip_addr[count] = data[6]
        }
      }
    }

    # search for addresses in INA flags
    if (run_flag == "TRUE" && addr_flag == "FALSE")
    {
      for (i in data)
      {
        if (data[i] ~ /^INA/)
        {
          # save IP address if available
          n = length(data[i]);
          if (n > 4)
          {
            test = get_value(substr(data[i], 5), "addr")
            if (test != "")
            {
              count++;
              ip_addr[count] = test
            }
          }
        }
      }
    }

    # search for addresses in IP flags
    if (run_flag == "TRUE" && addr_flag == "FALSE")
    {
      for (i in data)
      {
        if (data[i] ~ /^IP/)
        {
          # save IP address if available
          n = length(data[i]);
          if (n > 3)
          {
            test = get_value(substr(data[i], 4), "addr")
            if (test != "")
            {
              count++;
              ip_addr[count] = test
            }
          }
        }
      }
    }

    # de-duplication of hidden addresses
    if (run_flag == "TRUE")
    {
      for (i = 1; i <= count; i++)
      {
        if (ip_addr[i] != "")
        {
          for (j = i+1; j <= count; j++)
          {
            if (ip_addr[i] == ip_addr[j]) delete ip_addr[j]
          }
        }
      }
    }

    # output node
    if (run_flag == "TRUE")
    {
      conns = ""

      if (addr_flag == "TRUE")
      {
        # take data from IBN only
        for (i in ip_conn)
        {
          a_addr = get_value(ip_conn[i], "addr")
          a_port = get_value(ip_conn[i], "port")

          if (conns != "" && a_addr != "") conns = conns ";"

          if (a_addr != "" && a_port != "") conns = conns a_addr ":" a_port
          else if (a_addr != "") conns = conns a_addr
        }
      }
      else
      {
        # consider hidden addresses
        for (j in ip_addr)
        {
          test = "FALSE"

          if (ip_addr[j] != "")
          {
            if (conns != "") conns = conns ";"

            # combine address with ports from IBN 
            for (i in ip_conn)
            {
              test = "TRUE"
              a_port = get_value(ip_conn[i], "port")

              if (a_port != "") conns = conns ip_addr[j] ":" a_port
            }

            # no ports from IBN
            if (test == "FALSE")
            {
               conns = conns ip_addr[j]
            }
          }
        }
      }

      # write node data in binkd format
      if (conns != "") print "Node " address " " conns " -" >> binkd_nl
    }

    # clean up
    for (i in data)
      delete data[i]
    for (i in ip_conn)
      delete ip_conn[i]
    for (i in ip_addr)
      delete ip_addr[i]
  }

' "$NODELIST"

# the end
STAT=0                                      # exit status
